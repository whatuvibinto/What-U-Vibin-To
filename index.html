<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WHAT U VIBIN TO?</title>
    <link rel="stylesheet" href="css/style_index.css">
</head>
<body>

<div class="marquee-wrapper">
    <div class="marquee-content">
        WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// I WANNA GO TO AMSTERDAM /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// TOKYO /// STRICTLY VINYL ///
    </div>
</div>

<div class="container">
    <div class="header-logo-wrapper">
        <a href="index.html">
            <img src="images/logo.svg" alt="WHAT U VIBIN TO?">
        </a>
    </div>

    <div class="main-content">
        <nav class="nav-links">
            <a href="about.html">About</a>
            <a href="books.html">Books</a>
            <a href="contact.html">Contact</a>
            <a href="dig.html" class="special-link">Dig for new music</a>
            <a href="event.html">Events</a>
        </nav>

        <div class="record-wrapper" id="recordArea">
            <img src="images/record.svg" alt="Vinyl Record" class="record-img" id="recordDisk">
        </div>
    </div>

    <div class="footer">
        Developed by Lucy, Wassup bro
    </div>
</div>

<audio id="scratchAudio" src="scratch.mp3" preload="auto"></audio>
<script>
    /* --- JavaScript リアルスクラッチ機能 (Web Audio API版) --- */

    const recordArea = document.getElementById('recordArea');
    const recordDisk = document.getElementById('recordDisk');

    // --- Web Audio API 設定 ---
    let audioCtx;
    let audioBuffer;
    let sourceNode;
    let gainNode;
    let isAudioLoaded = false;

    // 音声ファイルを読み込む関数
    async function loadAudio(url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            isAudioLoaded = true;
        } catch (error) {
            console.error("Audio load failed:", error);
        }
    }

    // ページ読み込み時に音声をロード開始
    // ※実際の再生はユーザー操作（クリック等）が必要なため、mousedown等のタイミングでContextをResumeします
    loadAudio('scratch.mp3'); 

    function startSound() {
        if (!isAudioLoaded || !audioCtx) return;

        // 前の音が鳴っていたら止める
        if (sourceNode) {
            try { sourceNode.stop(); } catch(e){}
        }

        // 音源ノードの作成
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.loop = true; // ループさせることで途切れなく鳴らす

        // ゲイン（音量）ノードの作成
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 0; // 最初は音量0からスタート

        // 接続: Source -> Gain -> Speaker
        sourceNode.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        // 再生速度の初期値（停止状態に近い値だが、0にすると一部ブラウザで止まるため極小値にするか、計算で制御）
        sourceNode.playbackRate.value = 0; 
        
        sourceNode.start(0);
    }

    function updateSound(velocity) {
        if (!sourceNode || !gainNode) return;

        // 速度(velocity)に応じて再生速度(playbackRate)を変える
        // 感度調整: 0.15 という数値を大きくするとより敏感になります
        const playbackRate = velocity * 0.15;

        // Web Audio APIは playbackRate が負の値（逆再生）も扱える場合がありますが、
        // 簡易的なスクラッチ感演出のため、絶対値を使ってピッチ変化として扱います。
        // （本格的な逆再生はバッファ操作が必要で複雑なため）
        
        // 動きが止まっている時は音を小さく、動いている時は大きく
        if (Math.abs(velocity) > 0.5) {
            // 音量を上げる（フェードイン）
            gainNode.gain.setTargetAtTime(1, audioCtx.currentTime, 0.05);
        } else {
            // 音量を下げる
            gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
        }

        // ピッチ（速度）の適用。0だとエラーになることがあるので最小値を確保
        // Math.absを使って「速さ」だけを音の高さに変換するのが一番安定してスクラッチっぽく聞こえます
        let rate = Math.abs(playbackRate);
        if (rate < 0.1) rate = 0; // 遅すぎるときは0（停止）
        if (rate > 4.0) rate = 4.0; // 早すぎるときの上限

        // 滑らかに変化させる
        sourceNode.playbackRate.setTargetAtTime(rate, audioCtx.currentTime, 0.05);
    }

    function stopSound() {
        if (gainNode) {
            // 素早くフェードアウト
            gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
        }
        if (sourceNode) {
            // 少し待ってから停止（フェードアウトのため）
            setTimeout(() => {
                try { sourceNode.stop(); } catch(e){}
            }, 200);
        }
    }


    // --- 回転ロジック ---

    let isDragging = false;
    let startAngle = 0;
    let currentRotation = 0;
    let lastRotation = 0;
    let lastTime = 0;

    function getCenter(element) {
        const rect = element.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        };
    }

    function getAngle(x, y, center) {
        const dy = y - center.y;
        const dx = x - center.x;
        let theta = Math.atan2(dy, dx); 
        theta *= 180 / Math.PI; 
        return theta;
    }

    // マウスダウン / タッチスタート
    const startDrag = (clientX, clientY) => {
        isDragging = true;
        
        // AudioContextの制限解除（ユーザー操作が必要なためここで再開）
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
        }

        const center = getCenter(recordArea);
        startAngle = getAngle(clientX, clientY, center) - currentRotation;
        recordArea.style.cursor = 'grabbing';
        
        lastTime = Date.now();
        lastRotation = currentRotation;

        // 音の再生準備開始
        startSound();
    };

    // マウスムーブ / タッチムーブ
    const moveDrag = (clientX, clientY) => {
        if (!isDragging) return;

        const center = getCenter(recordArea);
        const angle = getAngle(clientX, clientY, center);
        const newRotation = angle - startAngle;
        
        // 回転の適用
        recordDisk.style.transform = `rotate(${newRotation}deg)`;

        // --- 速度計算 ---
        const now = Date.now();
        const deltaTime = now - lastTime;
        
        // 時間差が短すぎる（計算不能）な場合はスキップ
        if (deltaTime > 10) {
            const deltaRotation = newRotation - lastRotation;
            
            // 速度 = 回転角度の変化量 / 時間
            // これにより「どれくらいの勢いで回したか」が取れます
            const velocity = deltaRotation / deltaTime * 20; // *20は感度調整用の係数

            // 音の更新
            updateSound(velocity);

            lastRotation = newRotation;
            lastTime = now;
        }
        
        currentRotation = newRotation;
    };

    // マウスアップ / タッチエンド
    const endDrag = () => {
        isDragging = false;
        recordArea.style.cursor = 'grab';
        stopSound();
    };

    // --- イベントリスナー登録 ---

    // Mouse Events
    recordArea.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
    window.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
    window.addEventListener('mouseup', endDrag);

    // Touch Events
    recordArea.addEventListener('touchstart', (e) => {
        startDrag(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {
        moveDrag(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    
    window.addEventListener('touchend', endDrag);

</script>

</body>
</html>
