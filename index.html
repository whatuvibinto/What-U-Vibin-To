<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WHAT U VIBIN TO?</title>
    <link rel="stylesheet" href="css/style_index.css">
</head>
<body>

<div class="marquee-wrapper">
    <div class="marquee-content">
        WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// I WANNA GO TO AMSTERDAM /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? /// I WANNA GO TO AMSTERDAM /// WHAT U VIBIN TO? /// WHAT U VIBIN TO? ///
    </div>
</div>

<div class="container">
    <div class="header-logo-wrapper">
        <a href="index.html">
            <img src="images/logo.svg" alt="WHAT U VIBIN TO?">
        </a>
    </div>

    <div class="main-content">
        <nav class="nav-links">
            <a href="about.html">About</a>
            <a href="books.html">Books</a>
            <a href="contact.html">Contact</a>
            <a href="dig.html" class="special-link">Dig for new music</a>
            <a href="event.html">Events</a>
        </nav>

        <div class="record-wrapper" id="recordArea">
            <img src="images/record_v2.svg" alt="Vinyl Record" class="record-img" id="recordDisk">
        </div>
    </div>

    <div class="footer">
        Developed by Lucy, Wassup bro
    </div>
</div>

<audio id="scratchAudio" src="images/scratch.mp3" preload="auto"></audio>

<script>
    /* --- スマホ完全対応 リアルスクラッチ機能 --- */

    const recordArea = document.getElementById('recordArea');
    const recordDisk = document.getElementById('recordDisk');

    // 設定
    const AUDIO_URL = 'images/scratch.mp3'; 
    const FRICTION = 0.92;           // 摩擦（慣性）
    const SENSITIVITY = 1.2;         // スクラッチ感度

    // --- 変数 ---
    let audioCtx = null;
    let audioBuffer = null;
    let sourceNode = null;
    let gainNode = null;
    
    // 物理演算用
    let isDragging = false;
    let velocity = 0;
    let currentRotation = 0;
    let lastMouseAngle = 0;
    let lastTime = 0;
    let rafId = null;
    
    // スマホ用オーディオロック解除フラグ
    let isAudioUnlocked = false;

    // 1. 音声ファイルのロード
    async function loadAudio() {
        try {
            // AudioContextはユーザー操作の前に作っておく（状態はsuspendedになる）
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            
            const response = await fetch(AUDIO_URL);
            const arrayBuffer = await response.arrayBuffer();
            audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            console.log("Audio Loaded. Waiting for touch...");
        } catch (error) {
            console.error("Audio Load Error:", error);
            // スマホでローカルファイルを開いている場合の警告
            if (!location.protocol.startsWith('http')) {
                alert("注意: スマホで音を鳴らすには、Webサーバー(http/https)経由で開く必要があります。");
            }
        }
    }
    loadAudio();

    // 2. ★重要: スマホのオーディオロック解除関数
    function unlockAudio() {
        if (isAudioUnlocked || !audioCtx) return;

        // コンテキストがサスペンド状態なら再開させる
        if (audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                console.log("AudioContext Resumed");
            });
        }

        // 無音のバッファを一瞬再生して、オーディオエンジンを「暖機運転」させる
        const buffer = audioCtx.createBuffer(1, 1, 22050);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start(0);

        isAudioUnlocked = true;
        console.log("Audio Unlocked via Touch");
    }

    // 3. 音を鳴らす・速度を変える
    function updateSound(currentVelocity) {
        if (!audioCtx || !audioBuffer) return;

        // 音が鳴っていない、かつ速度が出ているなら再生開始
        if (!sourceNode && Math.abs(currentVelocity) > 0.1) {
            sourceNode = audioCtx.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.loop = true; // ループ再生

            gainNode = audioCtx.createGain();
            sourceNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            sourceNode.start(0);
        }

        if (sourceNode && gainNode) {
            // ピッチ（再生速度）の計算
            let speed = Math.abs(currentVelocity) * SENSITIVITY;
            
            // 制限
            if (speed > 3.0) speed = 3.0; 
            if (speed < 0.05) speed = 0;

            // 滑らかに変化させる（不快なノイズ防止）
            const now = audioCtx.currentTime;
            sourceNode.playbackRate.setTargetAtTime(speed, now, 0.02);
            
            // 音量（止まりかけは小さく）
            const volume = Math.min(speed, 1.0);
            gainNode.gain.setTargetAtTime(volume, now, 0.02);
        }
    }

    // 音を止める処理
    function stopSound() {
        if (sourceNode) {
            const node = sourceNode; // 参照をコピー
            const gain = gainNode;
            sourceNode = null; 
            gainNode = null;

            // プツッと切れないようにフェードアウトして停止
            if (gain && audioCtx) {
                gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                setTimeout(() => {
                    try { node.stop(); } catch(e){}
                }, 150);
            }
        }
    }

    // 4. アニメーションループ（物理演算）
    function animate() {
        if (!isDragging) {
            velocity *= FRICTION; // 摩擦で減速
        }

        // ほぼ停止したら速度0にする
        if (Math.abs(velocity) < 0.001) {
            velocity = 0;
            stopSound();
        } else {
            currentRotation += velocity;
            recordDisk.style.transform = `rotate(${currentRotation}deg)`;
            updateSound(velocity);
        }

        requestAnimationFrame(animate);
    }
    animate();

    // --- 座標計算系 ---
    function getCenter(el) {
        const rect = el.getBoundingClientRect();
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    function getAngle(x, y, center) {
        const dy = y - center.y;
        const dx = x - center.x;
        return Math.atan2(dy, dx) * (180 / Math.PI);
    }

    // --- イベントハンドラ ---
    
    function startDrag(x, y) {
        // ★ここでロック解除を実行
        unlockAudio();

        isDragging = true;
        const center = getCenter(recordArea);
        lastMouseAngle = getAngle(x, y, center);
        lastTime = Date.now();
        recordArea.style.cursor = 'grabbing';
    }

    function moveDrag(x, y) {
        if (!isDragging) return;
        const center = getCenter(recordArea);
        const angle = getAngle(x, y, center);

        let delta = angle - lastMouseAngle;
        // 角度の境界またぎ処理 (-180 <-> 180)
        while (delta <= -180) delta += 360;
        while (delta > 180) delta -= 360;

        velocity = delta; // 速度を更新
        lastMouseAngle = angle;
    }

    function endDrag() {
        isDragging = false;
        recordArea.style.cursor = 'grab';
    }

    // --- イベントリスナー登録 ---

    // Mouse
    recordArea.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
    window.addEventListener('mouseup', endDrag);

    // Touch
    // passive: false はスクロール防止のために必須
    recordArea.addEventListener('touchstart', e => {
        // e.preventDefault(); // 必要に応じて有効化（画面スクロールを完全に止める場合）
        startDrag(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    window.addEventListener('touchmove', e => {
        e.preventDefault(); // スクラッチ中の画面スクロールを防止
        moveDrag(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    window.addEventListener('touchend', endDrag);

</script>

</body>
</html>
